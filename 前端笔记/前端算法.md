## 时间复杂度
> 时间复杂度是衡量算法执行时间长短的一个度量指标。它表示随着问题规模的增大，算法执行时间的增长趋势。
>

### O(1) - 常数时间复杂度
> 不论问题规模大小，算法的执行时间都保持不变。
>

```javascript
function printNumber(num) {
  console.log(num);
}
```

### O(n) - 线性时间复杂度
> 随着问题规模 n 的增加，算法的执行时间是线性增长的。
>

```javascript
function printNumbers(n) {
  for (let i = 1; i <= n; i++) {
    console.log(i);
  }
}
```

### O(n^2) - 平方时间复杂度
> 随着问题规模 n 的增加，算法的执行时间是以平方的方式增长的。
>

```javascript
function printAllPairs(numbers) {
  for (let i = 0; i < numbers.length; i++) {
    for (let j = 0; j < numbers.length; j++) {
      console.log(numbers[i], numbers[j]);
    }
  }
}
```

### O(log n) - 对数时间复杂度
> 随着问题规模 n 的增加，算法的执行时间是以对数的方式增长的。
>

```javascript
// 二分查找算法
// 它能在一个有序数组中查找目标元素的位置。每次迭代中，我们将搜索范围折半，因此算法的执行次数与问题规模n的对数呈正比。
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

### O(2^n) - 指数时间复杂度
> 随着问题规模n的增加，算法的执行时间是以指数的方式增长的。
>

```javascript
// 斐波那契数列计算算法
// 它使用递归的方式计算第n个斐波那契数。每次递归调用会产生两个更小规模的子问题，因此递归树的节点数会以指数的方式增长。
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }

  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

## 空间复杂度
> 空间复杂度是算法在执行过程中所需的存储空间的量度。它表示该算法解决问题所需的额外空间。空间复杂度可以用来评估算法的内存消耗情况。
>

### O(1) - 常量空间复杂度
> 表示算法所需的额外空间是一个常数，与输入规模无关。
>

```javascript
function sum(a, b) {
  let result = a + b;
  return result;
}
```

### O(n) - 线性空间复杂度
> 表示算法所需的额外空间与输入规模成正比。
>

```javascript
function reverseArray(arr) {
  let reversed = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    reversed.push(arr[i]);
  }
  return reversed;
}
```

### O(n^2) - 二次空间复杂度
> 表示算法所需的额外空间与输入规模的平方成正比。
>

```javascript
// matrixMultiplication函数接收两个矩阵作为输入，并创建了一个新的矩阵result来存储两个矩阵的乘积。
function matrixMultiplication(matrix1, matrix2) {
  let result = [];
  for (let i = 0; i < matrix1.length; i++) {
    result[i] = [];
    for (let j = 0; j < matrix2[0].length; j++) {
      result[i][j] = 0;
      for (let k = 0; k < matrix1[0].length; k++) {
        result[i][j] += matrix1[i][k] * matrix2[k][j];
      }
    }
  }
  return result;
}
```

### O(log n) - 对数空间复杂度
> 表示算法所需的额外空间与输入规模的对数成正比。
>

```javascript
// binarySearch函数实现一种二分搜索算法，用于在有序数组中查找目标值。算法通过重复将搜索范围减半来定位目标值的位置。尽管在执行过程中使用了不同的变量，算法需要额外的空间来存储上界、下界和中间索引。
function binarySearch(arr, target) {
  let low = 0;
  let high = arr.length - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return -1;
}
```

## 栈
> 栈（Stack）是一种常见的数据结构，它遵循后进先出（LIFO，Last In, First Out）的原则。栈有两个主要操作：入栈（push）和出栈（pop）。
>

### 力扣 - 20. 有效的括号
> [https://leetcode.cn/problems/valid-parentheses/](https://leetcode.cn/problems/valid-parentheses/)
>

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

> **输入：**s = "()"
>
> **输出：**true
>

**示例 2：**

> **输入：**s = "()[]{}"
>
> **输出：**true
>

**示例 3：**

> **输入：**s = "(]"
>
> **输出：**false
>

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  let stack = []
  let map = {
    '(': ')',
    '[': ']',
    '{': '}'
  }
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]]) {
      stack.push(s[i])
    } else {
      if (stack.length === 0 || map[stack.pop()] !== s[i]) {
        return false
      }
    }
  }
  return stack.length === 0
}

// 执行结果
console.log(isValid('()')) // true
console.log(isValid('()[]{}')) // true
console.log(isValid('(]')) // false
```

### 力扣 - 1047. 删除字符串中的所有相邻重复项
> [https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
>

给出由小写字母组成的字符串 S，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

> **输入：**"abbaca"
>
> **输出：**"ca"
>
> **解释：**
>
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
>

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function (s) {
  let stack = []
  let res = ''
  for (let i = 0; i < s.length; i++) {
    if (stack.length === 0 || stack[stack.length - 1] !== s[i]) {
      stack.push(s[i])
    } else {
      stack.pop()
    }
  }
  for (let i = 0; i < stack.length; i++) {
    res += stack[i]
  }
  return res
}

// 执行结果
console.log(removeDuplicates('abbaca')) // ca
console.log(removeDuplicates('azxxzy')) // ay
```

### 力扣 - 71. 简化路径
> [https://leetcode.cn/problems/simplify-path/](https://leetcode.cn/problems/simplify-path/)
>

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

+ 始终以斜杠 '/' 开头。
+ 两个目录名之间必须只有一个斜杠 '/' 。
+ 最后一个目录名（如果存在）不能 以 '/' 结尾。
+ 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。

返回简化后得到的 **规范路径** 。

**示例 1：**

> **输入：**path = "/home/"
>
> **输出：**"/home"
>
> **解释：**注意，最后一个目录名后面没有斜杠。
>

**示例 2：**

> **输入：**path = "/../"
>
> **输出：**"/"
>
> **解释：**从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
>

**示例 3：**

> **输入：**path = "/home//foo/"
>
> **输出：**"/home/foo"
>
> **解释：**在规范路径中，多个连续斜杠需要用一个斜杠替换。
>

**示例 4：**

> **输入：**path = "/a/./b/../../c/"
>
> **输出：**"/c"
>

```javascript
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function (path) {
  const stack = []
  const pathArr = path.split('/')
  for (let i = 0; i < pathArr.length; i++) {
    if (pathArr[i] === '' || pathArr[i] === '.') {
      continue
    }
    if (pathArr[i] === '..') {
      stack.pop()
    } else {
      stack.push(pathArr[i])
    }
  }
  return '/' + stack.join('/')
}

// 执行结果
console.log(simplifyPath('/home/')) // /home
console.log(simplifyPath('/../')) // /
console.log(simplifyPath('/home//foo/')) // /home/foo
console.log(simplifyPath('/a/./b/../../c/')) // /c
```

## 队列
> 队列是一种具有先进先出（FIFO）特性的数据结构。它类似于现实生活中的排队，元素在队尾插入，从队头移除。在队列中，只能从队头删除元素，只能从队尾添加元素。常见的队列操作包括入队（enqueuing）和出队（dequeuing）。
>

### 力扣 - 933. 最近的请求次数
> [https://leetcode.cn/problems/number-of-recent-calls/](https://leetcode.cn/problems/number-of-recent-calls/)
>

写一个 `**RecentCounter**` 类来计算特定时间范围内最近的请求。

请你实现 `**RecentCounter**` 类：

+ `**RecentCounter()**` 初始化计数器，请求数为 0 。
+ `**int ping(int t)**` 在时间 `**t**` 添加一个新请求，其中 `**t**` 表示以毫秒为单位的某个时间，并返回过去 `**3000**` 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 `**[t-3000, t]**` 内发生的请求数。

**保证** 每次对 `**ping**` 的调用都使用比之前更大的 `**t**` 值。

**示例 1：**

> **输入：**
>
> ["RecentCounter", "ping", "ping", "ping", "ping"]
>
> [[], [1], [100], [3001], [3002]]
>
> **输出：**
>
> [null, 1, 2, 3, 3]
>
> **解释：**
>
> RecentCounter recentCounter = new RecentCounter();
>
> recentCounter.ping(1);     // requests = [**1**]，范围是 [-2999,1]，返回 1
>
> recentCounter.ping(100);   // requests = [**1**, **100**]，范围是 [-2900,100]，返回 2
>
> recentCounter.ping(3001);  // requests = [**1**, **100**, **3001**]，范围是 [1,3001]，返回 3
>
> recentCounter.ping(3002);  // requests = [1, **100**, **3001**, **3002**]，范围是 [2,3002]，返回 3
>

```javascript
var RecentCounter = function () {
  this.queue = []
}

/**
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
  this.queue.push(t)
  while (this.queue[0] < t - 3000) {
    this.queue.shift()
  }
  return this.queue.length
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */

// 执行结果
const recentCounter = new RecentCounter()
console.log(recentCounter.ping(1)) // 1
console.log(recentCounter.ping(100)) // 2
console.log(recentCounter.ping(3001)) // 3
console.log(recentCounter.ping(3002)) // 3
```

## 链表
> 链表（LinkedList）是一种常见的数据结构，它由一系列节点（Node）组成，每个节点包含两个部分：数据和指向下一个节点的指针（或引用）。
>

### 力扣 - 141. 环形链表
> [https://leetcode.cn/problems/linked-list-cycle/](https://leetcode.cn/problems/linked-list-cycle/)
>

给你一个链表的头节点 `**head**` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `**next**` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `**pos**` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：**`**pos**` **不作为参数进行传递 **。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 `**true**` 。 否则，返回 `**false**` 。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/png/33977556/1693230346570-2655fc76-6bc5-4a16-ba92-74cf22a042a6.png)

> **输入：**head = [3,2,0,-4], pos = 1
>
> **输出：**true
>
> **解释：**链表中有一个环，其尾部连接到第二个节点。
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/png/33977556/1693230398761-253bcea1-0319-4cb2-b3dc-66c1d53b3ce2.png)

> **输入：**head = [1,2], pos = 0
>
> **输出：**true
>
> **解释：**链表中有一个环，其尾部连接到第一个节点。
>

**示例 3：**

![](https://cdn.nlark.com/yuque/0/2023/png/33977556/1693230436896-7ca97e5c-a1f4-405d-b24a-227214773479.png)

> **输入：**head = [1], pos = -1
>
> **输出：**false
>
> **解释：**链表中没有环。
>

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  let fast = head
  let slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}

// 测试用例
const head1 = {
  val: 3,
  next: {
    val: 2,
    next: {
      val: 0,
      next: {
        val: -4,
        next: null
      }
    }
  }
}

head1.next.next.next = head1.next

const head2 = {
  val: 1,
  next: {
    val: 2,
    next: null
  }
}

head2.next.next = head2

const head3 = {
  val: 1,
  next: null
}

// 执行结果
console.log(hasCycle(head1)) // true
console.log(hasCycle(head2)) // true
console.log(hasCycle(head3)) // false
```

### 力扣 - 237. 删除链表中的节点
> [https://leetcode.cn/problems/delete-node-in-a-linked-list/](https://leetcode.cn/problems/delete-node-in-a-linked-list/)
>

有一个单链表的 `**head**`，我们想删除它其中的一个节点 `**node**`。

给你一个需要删除的节点 `**node**` 。你将 **无法访问** 第一个节点  `**head**`。

链表的所有值都是 **唯一的**，并且保证给定的节点 `**node**` 不是链表中的最后一个节点。

删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：

+ 给定节点的值不应该存在于链表中。
+ 链表中的节点数应该减少 1。
+ `**node**` 前面的所有值顺序相同。
+ `**node**` 后面的所有值顺序相同。

**自定义测试：**

+ 对于输入，你应该提供整个链表 `**head**` 和要给出的节点 `**node**`。`**node**` 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。
+ 我们将构建链表，并将节点传递给你的函数。
+ 输出将是调用你函数后的整个链表。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693231311993-3d93478f-02ac-4167-83ec-4abdb56ee0a9.jpeg)

> **输入：**head = [4,5,1,9], node = 5
>
> **输出：**[4,1,9]
>
> **解释：**指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693231354074-e3166c21-5cdb-4c57-bddd-596803196724.jpeg)

> **输入：**head = [4,5,1,9], node = 1
>
> **输出：**[4,5,9]
>
> **解释：**指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
>

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function (node) {
  node.val = node.next.val
  node.next = node.next.next
}

// 测试用例
const head1 = {
  val: 4,
  next: {
    val: 5,
    next: {
      val: 1,
      next: {
        val: 9,
        next: null
      }
    }
  }
}
const node1 = head1.next

const head2 = {
  val: 4,
  next: {
    val: 5,
    next: {
      val: 1,
      next: {
        val: 9,
        next: null
      }
    }
  }
}
const node2 = head2.next.next

// 执行结果
deleteNode(node1)
deleteNode(node2)
console.log(head1) // { val: 4, next: { val: 1, next: { val: 9, next: null } } }
console.log(head2) // { val: 4, next: { val: 5, next: { val: 9, next: null } } }
```

### 力扣 - 83. 删除排序链表中的重复元素
> [https://leetcode.cn/problems/remove-duplicates-from-sorted-list/](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)
>

给定一个已排序的链表的头 `**head**` ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693231898355-5cf24a5d-ae47-4b67-aa0f-4bc9e5cd682f.jpeg)

> **输入：**head = [1,1,2]
>
> **输出：**[1,2]
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693231930860-11c2e7ea-00dd-4bd0-916e-13960829822b.jpeg)

> **输入：**head = [1,1,2,3,3]
>
> **输出：**[1,2,3]
>

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
  if (!head) return head
  let cur = head
  while (cur.next) {
    if (cur.val === cur.next.val) {
      cur.next = cur.next.next
    } else {
      cur = cur.next
    }
  }
  return head
}

// 测试用例
const head1 = {
  val: 1,
  next: {
    val: 1,
    next: {
      val: 2,
      next: null
    }
  }
}

const head2 = {
  val: 1,
  next: {
    val: 2,
    next: {
      val: 2,
      next: {
        val: 3,
        next: {
          val: 3,
          next: null
        }
      }
    }
  }
}

// 执行结果
console.log(deleteDuplicates(head1)) // { val: 1, next: { val: 2, next: null } }
console.log(deleteDuplicates(head2)) // { val: 1, next: { val: 2, next: { val: 3, next: null } } }
```

### 力扣 - 206. 反转链表
> [https://leetcode.cn/problems/reverse-linked-list/](https://leetcode.cn/problems/reverse-linked-list/)
>

给你单链表的头节点 `**head**` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693398842828-85be7f84-159a-4b4d-8644-4d1757852577.jpeg)

> **输入：**head = [1,2,3,4,5]
>
> **输出：**[5,4,3,2,1]
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1693398887389-9a359523-dba2-483e-8e3a-4cc622539781.jpeg)

> **输入：**head = [1,2]
>
> **输出：**[2,1]
>

**示例 3：**

> **输入：**head = []
>
> **输出：**[]
>

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  let prev = null
  let cur = head
  while (cur) {
    let next = cur.next
    cur.next = prev
    prev = cur
    cur = next
  }
  return prev
}

// 测试用例
var head1 = {
  val: 1,
  next: {
    val: 2,
    next: {
      val: 3,
      next: {
        val: 4,
        next: {
          val: 5,
          next: null
        }
      }
    }
  }
}

var head2 = {
  val: 1,
  next: {
    val: 2,
    next: null
  }
}

var head3 = null

// 执行结果
console.log(JSON.stringify(reverseList(head1))) // {"val":5,"next":{"val":4,"next":{"val":3,"next":{"val":2,"next":{"val":1,"next":null}}}}}
console.log(JSON.stringify(reverseList(head2))) // {"val":2,"next":{"val":1,"next":null}}
console.log(JSON.stringify(reverseList(head3))) // null
```

## 字典
> 字典（Dictionary）是一种数据结构，也被称为映射（Map）或关联数组（Associative Array）。它是一种无序的键值对集合，其中每个键（key）都唯一且与一个值（value）相关联。
>

### 力扣 - 1. 两数之和
> [https://leetcode.cn/problems/two-sum/](https://leetcode.cn/problems/two-sum/)
>

给定一个整数数组 `**nums**` 和一个整数目标值 `**target**`，请你在该数组中找出 和为目标值 `**target **` 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

> **输入：**nums = [2,7,11,15], target = 9
>
> **输出：**[0,1]
>
> **解释：**因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
>

**示例 2：**

> **输入：**nums = [3,2,4], target = 6
>
> **输出：**[1,2]
>

**示例 3：**

> **输入：**nums = [3,3], target = 6
>
> **输出：**[0,1]
>

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  let map = new Map()
  for (let i = 0; i < nums.length; i++) {
    let num = nums[i]
    if (map.has(num)) {
      return [map.get(num), i]
    } else {
      map.set(target - num, i)
    }
  }
  return []
}

// 执行结果
console.log(twoSum([2, 7, 11, 15], 9)) // [0,1]
console.log(twoSum([3, 2, 4], 6)) // [1,2]
console.log(twoSum([3, 3], 6)) // [0,1]
```

### 力扣 - 217. 存在重复元素
> [https://leetcode.cn/problems/contains-duplicate/](https://leetcode.cn/problems/contains-duplicate/)
>

给你一个整数数组 `**nums**` 。如果任一值在数组中出现 至少两次 ，返回 `**true**` ；如果数组中每个元素互不相同，返回 `**false**` 。

**示例 1：**

> **输入：**nums = [1,2,3,1]
>
> **输出：**true
>

**示例 2：**

> **输入：**nums = [1,2,3,4]
>
> **输出：**false
>

**示例 3：**

> **输入：**nums = [1,1,1,3,3,4,3,2,4,2]
>
> **输出：**true
>

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function (nums) {
  let set = new Set()
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      return true
    }
    set.add(nums[i])
  }
  return false
}

// 执行结果
console.log(containsDuplicate([1, 2, 3, 1])) // true
console.log(containsDuplicate([1, 2, 3, 4])) // false
console.log(containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2])) // true
```

### 力扣 - 349. 两个数组的交集
> [https://leetcode.cn/problems/intersection-of-two-arrays/](https://leetcode.cn/problems/intersection-of-two-arrays/)
>

**示例 1：**

> **输入：**nums1 = [1,2,2,1], nums2 = [2,2]
>
> **输出：**[2]
>

**示例 2：**

> **输入：**nums1 = [4,9,5], nums2 = [9,4,9,8,4]
>
> **输出：**[9,4]
>
> **解释：**[4,9] 也是可通过的
>

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function (nums1, nums2) {
  const set1 = new Set(nums1)
  const set2 = new Set(nums2)
  const intersection = new Set()

  for (let num of set1) {
    if (set2.has(num)) {
      intersection.add(num)
    }
  }

  return Array.from(intersection)
}

// 执行结果
console.log(intersection([1, 2, 2, 1], [2, 2])) // [2]
console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4])) // [4, 9]
```

### 力扣 - 1207. 独一无二的出现次数
> [https://leetcode.cn/problems/unique-number-of-occurrences/](https://leetcode.cn/problems/unique-number-of-occurrences/)
>

给你一个整数数组 `**arr**`，请你帮忙统计数组中每个数的出现次数。

如果每个数的出现次数都是独一无二的，就返回 `**true**`；否则返回 `**false**`。

**示例 1：**

> **输入：**arr = [1,2,2,1,1,3]
>
> **输出：**true
>
> **解释：**在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
>

**示例 2：**

> **输入：**arr = [1,2]
>
> **输出：**false
>

**示例 3：**

> **输入：**arr = [-3,0,1,-3,1,1,1,-3,10,0]
>
> **输出：**true
>

```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var uniqueOccurrences = function (arr) {
  let map = new Map()
  for (let i = 0; i < arr.length; i++) {
    if (map.has(arr[i])) {
      map.set(arr[i], map.get(arr[i]) + 1)
    } else {
      map.set(arr[i], 1)
    }
  }
  let set = new Set()
  for (let [key, value] of map) {
    if (set.has(value)) {
      return false
    }
    set.add(value)
  }
  return true
}

// 执行结果
console.log(uniqueOccurrences([1, 2, 2, 1, 1, 3])) // true
console.log(uniqueOccurrences([1, 2])) // false
console.log(uniqueOccurrences([-3, 0, 1, -3, 1, 1, 1, -3, 10, 0])) // true
```

### 力扣 - 3. 无重复字符的最长子串
> [https://leetcode.cn/problems/longest-substring-without-repeating-characters/](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
>

给定一个字符串 `**s**` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

> **输入:** s = "abcabcbb"
>
> **输出: **3 
>
> **解释: **因为无重复字符的最长子串是 `**"abc"**`，所以其长度为 3。
>

**示例 2:**

> **输入: **s = "bbbbb"
>
> **输出: **1
>
> **解释: **因为无重复字符的最长子串是 `**"b"**`，所以其长度为 1。
>

**示例 3:**

> **输入:** s = "pwwkew"
>
> **输出:** 3
>
> **解释:** 因为无重复字符的最长子串是 `**"wke"**`，所以其长度为 3。
>
>  请注意，你的答案必须是 **子串** 的长度，`**"pwke"**` 是一个子序列，不是子串。
>

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  let max = 0
  let start = 0
  let map = new Map()
  for (let i = 0; i < s.length; i++) {
    if (map.has(s[i])) {
      start = Math.max(start, map.get(s[i]) + 1)
    }
    map.set(s[i], i)
    max = Math.max(max, i - start + 1)
  }
  return max
}

// 执行结果
console.log(lengthOfLongestSubstring('abcabcbb')) // 3
console.log(lengthOfLongestSubstring('bbbbb')) // 1
console.log(lengthOfLongestSubstring('pwwkew')) // 3
```

## 树
> 树是一种数据结构，它由节点和边组成，其中每个节点可以有零个或多个子节点。
>

### 深度优先遍历（DFS）
> 深度优先遍历是一种先访问根节点，然后递归地访问子节点的遍历方式。
>

```javascript
// node表示当前节点，node.value表示节点的值，node.children表示节点的子节点数组。
// 首先访问当前节点，然后递归地访问每个子节点。
function dfs(node) {
  if (node === null) {
    return;
  }
  
  console.log(node.value); // 访问当前节点
  
  node.children.forEach(child => {
    dfs(child); // 递归访问子节点
  });
}
```

### 广度优先遍历（BFS）
> 广度优先遍历是一种先访问根节点，然后逐层访问子节点的遍历方式。
>

```javascript
// root表示根节点，node.value表示节点的值，node.children表示节点的子节点数组。
// 首先将根节点加入队列，然后循环遍历队列，每次取出队列中的第一个节点并访问，然后将其子节点加入队列。
function bfs(root) {
  if (root === null) {
    return;
  }
  
  const queue = [root]; // 使用队列存储待访问的节点
  
  while (queue.length > 0) {
    const node = queue.shift(); // 取出队列中的第一个节点
    console.log(node.value); // 访问当前节点
    
    node.children.forEach(child => {
      queue.push(child); // 将子节点加入队列
    });
  }
}
```

### 二叉树
#### 力扣 - 144. 二叉树的前序遍历
> [https://leetcode.cn/problems/binary-tree-preorder-traversal/](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
>

给你二叉树的根节点 `**root**` ，返回它节点值的 **前序** 遍历。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694357477377-b1a63175-86d9-43d2-901d-91e2f34cf0c0.jpeg)

> **输入：**root = [1,null,2,3]
>
> **输出：**[1,2,3]
>

**示例 2：**

> **输入：**root = []
>
> **输出：**[]
>

**示例 3：**

> **输入：**root = [1]
>
> **输出：**[1]
>

**示例 4：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694357570168-9e245919-63a9-4311-821a-452a32676cfe.jpeg)

> **输入：**root = [1,2]
>
> **输出：**[1,2]
>

**示例 5：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694357600459-73358fb7-a21c-4b40-bd90-f74067bc0496.jpeg)

> **输入：**root = [1,null,2]
>
> **输出：**[1,2]
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
  if (!root) return []
  let res = []
  let stack = [root]
  while (stack.length) {
    let node = stack.pop()
    res.push(node.val)
    if (node.right) stack.push(node.right)
    if (node.left) stack.push(node.left)
  }
  return res
}

// 测试用例
var root1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null
    },
    right: null
  }
}

var root2 = null

var root3 = {
  val: 1,
  left: null,
  right: null
}

var root4 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null
  },
  right: null
}

var root5 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null
  }
}

// 执行结果
console.log(preorderTraversal(root1)) // [1, 2, 3]
console.log(preorderTraversal(root2)) // []
console.log(preorderTraversal(root3)) // [1]
console.log(preorderTraversal(root4)) // [1, 2]
console.log(preorderTraversal(root5)) // [1, 2]
```

#### 力扣 - 94. 二叉树的中序遍历
> [https://leetcode.cn/problems/binary-tree-inorder-traversal/description/](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
>

给定一个二叉树的根节点 `**root**` ，返回 它的 **中序** 遍历 。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694446351690-82bd9fda-0901-49da-b366-bdfcd9a7baea.jpeg)

> **输入：**root = [1,null,2,3]
>
> **输出：**[1,3,2]
>

**示例 2：**

> **输入：**root = []
>
> **输出：**[]
>

**示例 3：**

> **输入：**root = [1]
>
> **输出：**[1]
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  let result = []
  let stack = []
  let node = root
  while (node || stack.length > 0) {
    while (node) {
      stack.push(node)
      node = node.left
    }
    node = stack.pop()
    result.push(node.val)
    node = node.right
  }
  return result
}

// 测试用例
var root1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null
    },
    right: null
  }
}

var root2 = null

var root3 = {
  val: 1,
  left: null,
  right: null
}

// 执行结果
console.log(inorderTraversal(root1)) // [1, 3, 2]
console.log(inorderTraversal(root2)) // []
console.log(inorderTraversal(root3)) // [1]
```

#### 力扣 - 145. 二叉树的后序遍历
> [https://leetcode.cn/problems/binary-tree-postorder-traversal/description/](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)
>

给你一棵二叉树的根节点 `**root**` ，返回其节点值的 **后序遍历** 。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694448117667-488fb755-6153-409a-bc60-26bd0639faca.jpeg)

> **输入：**root = [1,null,2,3]
>
> **输出：**[3,2,1]
>

**示例 2：**

> **输入：**root = []
>
> **输出：**[]
>

**示例 3：**

> **输入：**root = [1]
>
> **输出：**[1]
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {
  if (!root) return []
  let res = []
  let stack = [root]
  while (stack.length) {
    let node = stack.pop()
    res.unshift(node.val)
    if (node.left) stack.push(node.left)
    if (node.right) stack.push(node.right)
  }
  return res
}

// 测试用例
var root1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null
    },
    right: null
  }
}

var root2 = null

var root3 = {
  val: 1,
  left: null,
  right: null
}

// 执行结果
console.log(postorderTraversal(root1)) // [3,2,1]
console.log(postorderTraversal(root2)) // []
console.log(postorderTraversal(root3)) // [1]

```

#### 力扣 - 111. 二叉树的最小深度
> [https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)
>

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694448833068-a07a9ad9-5ff6-4d4c-aa4f-801ac0f3c4c2.jpeg)

> **输入：**root = [3,9,20,null,null,15,7]
>
> **输出：**2
>

**示例 2：**

> **输入：**root = [2,null,3,null,4,null,5,null,6]
>
> **输出：**5
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  if (!root) {
    return 0
  }
  if (!root.left && !root.right) {
    return 1
  }
  let min = Infinity
  if (root.left) {
    min = Math.min(minDepth(root.left), min)
  }
  if (root.right) {
    min = Math.min(minDepth(root.right), min)
  }
  return min + 1
}

// 测试用例
var root1 = {
  val: 3,
  left: {
    val: 9,
    left: null,
    right: null
  },
  right: {
    val: 20,
    left: {
      val: 15,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    }
  }
}

var root2 = {
  val: 2,
  left: null,
  right: {
    val: 3,
    left: null,
    right: {
      val: 4,
      left: null,
      right: {
        val: 5,
        left: null,
        right: {
          val: 6,
          left: null,
          right: null
        }
      }
    }
  }
}

// 执行结果
console.log(minDepth(root1)) // 2
console.log(minDepth(root2)) // 5
```

#### 力扣 - 104. 二叉树的最大深度
> [https://leetcode.cn/problems/maximum-depth-of-binary-tree/](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
>

给定一个二叉树 `**root**` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1694533081079-3d514e29-d6bb-4a65-98f4-da9067046086.jpeg)

> **输入：**root = [3,9,20,null,null,15,7]
>
> **输出：**3
>

**示例 2：**

> **输入：**root = [1,null,2]
>
> **输出：**2
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
  if (root === null) return 0
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
}

// 测试用例
var root1 = {
  val: 3,
  left: {
    val: 9,
    left: null,
    right: null
  },
  right: {
    val: 20,
    left: {
      val: 15,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    }
  }
}

var root2 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null
  }
}

// 执行结果
console.log(maxDepth(root1)) // 3
console.log(maxDepth(root2)) // 2
```

#### 力扣 - 226. 翻转二叉树
> [https://leetcode.cn/problems/invert-binary-tree/description/](https://leetcode.cn/problems/invert-binary-tree/description/)
>

给你一棵二叉树的根节点 `**root**` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1696163856528-53fb04ef-fbba-499c-aa62-1e71b42374b9.jpeg)

> **输入：**root = [4,2,7,1,3,6,9]
>
> **输出：**[4,7,2,9,6,3,1]
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1696163893654-1b9de796-50b9-49d0-8e79-b8d3905f8869.jpeg)

> **输入：**root = [2,1,3]
>
> **输出：**[2,3,1]
>

**示例 3：**

> **输入：**root = []
>
> **输出：**[]
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (!root) return null
  let left = invertTree(root.left)
  let right = invertTree(root.right)
  root.left = right
  root.right = left
  return root
}

// 测试用例
var root1 = {
  val: 4,
  left: {
    val: 2,
    left: { val: 1 },
    right: { val: 3 }
  },
  right: {
    val: 7,
    left: { val: 6 },
    right: { val: 9 }
  }
}

var root2 = {
  val: 2,
  left: {
    val: 1,
    left: null,
    right: null
  },
  right: {
    val: 3,
    left: null,
    right: null
  }
}

var root3 = null

// 执行结果
console.log(invertTree(root1)) // { val: 4, left: { val: 7, left: { val: 9, left: null, right: null }, right: { val: 6, left: null, right: null }}, right: { val: 2, left: { val: 3, left: null, right: null }, right: { val: 1, left: null, right: null }}}
console.log(invertTree(root2)) // { val: 2, left: { val: 3, left: null, right: null }, right: { val: 1, left: null, right: null }}
console.log(invertTree(root3)) // null
```

#### 力扣 - 100. 相同的树
> [https://leetcode.cn/problems/same-tree/description/](https://leetcode.cn/problems/same-tree/description/)
>

给你两棵二叉树的根节点 `**p**` 和 `**q**` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1696164559881-c2e6d18a-5f83-4976-9c6c-ab9da018a006.jpeg)

> **输入：**p = [1,2,3], q = [1,2,3]
>
> **输出：**true
>

**示例 2：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1696164619016-e0428e53-930e-4d09-bcb3-679b9a91b5c1.jpeg)

> **输入：**p = [1,2], q = [1,null,2]
>
> **输出：**false
>

**示例 3：**

![](https://cdn.nlark.com/yuque/0/2023/jpeg/33977556/1696164650108-b71aa8d9-da17-4485-b782-8c9de9877ef7.jpeg)

> **输入：**p = [1,2,1], q = [1,1,2]
>
> **输出：**false
>

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {
  if (p === null && q === null) {
    return true
  }
  if (p === null || q === null) {
    return false
  }
  if (p.val !== q.val) {
    return false
  }
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
}

// 测试用例
var p1 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null
  },
  right: {
    val: 3,
    left: null,
    right: null
  }
}
var q1 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null
  },
  right: {
    val: 3,
    left: null,
    right: null
  }
}

var p2 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null
  },
  right: null
}
var q2 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null
  }
}

var p3 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null
  },
  right: {
    val: 1,
    left: null,
    right: null
  }
}
var q3 = {
  val: 1,
  left: {
    val: 1,
    left: null,
    right: null
  },
  right: {
    val: 2,
    left: null,
    right: null
  }
}

// 执行结果
console.log(isSameTree(p1, q1)) // true
console.log(isSameTree(p2, q2)) // false
console.log(isSameTree(p3, q3)) // false
```

## 堆
> 堆（Heap）是一种常见的数据结构，也是一种特殊的完全二叉树。堆通常用于实现优先队列，其中每个元素都有一个与之关联的优先级。
>

+ **最大堆：**在最大堆中，父节点的值大于或等于其子节点的值，即任意节点的值不小于其子节点的值。根节点是整个堆中的最大值。
+ **最小堆：**在最小堆中，父节点的值小于或等于其子节点的值，即任意节点的值不大于其子节点的值。根节点是整个堆中的最小值。

堆的特性：

+ **完全二叉树结构：**除了最底层外，其他层的节点必须填满，且最底层的节点从左到右依次填入。
+ **堆序性质：**最大堆中，父节点的值大于或等于子节点的值；最小堆中，父节点的值小于或等于子节点的值。

### 力扣 - 215. 数组中的第K个最大元素
> [https://leetcode.cn/problems/kth-largest-element-in-an-array/description/](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)
>

给定整数数组 `**nums**` 和整数 `**k**`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `**k**` 个最大的元素，而不是第 `**k**` 个不同的元素。

你必须设计并实现时间复杂度为 `**O(n)**` 的算法解决此问题。

**示例 1:**

> **输入: **`**[3,2,1,5,6,4]**`, k = 2
>
> **输出: **5
>

**示例 2:**

> **输入: **`**[3,2,3,1,2,4,5,5,6]**`, k = 4
>
> **输出: **4
>

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function (nums, k) {
    return nums.sort((a, b) => b - a)[k - 1]
}

// 测试用例
var nums1 = [3, 2, 1, 5, 6, 4], k1 = 2
var nums2 = [3, 2, 3, 1, 2, 4, 5, 5, 6], k2 = 4

// 执行结果
console.log(findKthLargest(nums1, k1)) // 5
console.log(findKthLargest(nums2, k2)) // 4
```

## 算法
### 排序
#### 冒泡排序
```javascript
function bubbleSort(arr) {
  let len = arr.length
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }
  return arr
}

// 测试用例
let arr = [10, 4, 3, 2, 8, 6, 7, 1, 9, 5]

// 执行结果
console.log(bubbleSort(arr)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### 选择排序
```javascript
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    if (minIndex !== i) {
      let temp = arr[i]
      arr[i] = arr[minIndex]
      arr[minIndex] = temp
    }
  }
  return arr
}

// 测试用例
let arr = [10, 4, 3, 2, 8, 6, 7, 1, 9, 5]

// 执行结果
console.log(selectSort(arr)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### 插入排序
```javascript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let temp = arr[i]
    let j = i - 1
    while (j >= 0 && arr[j] > temp) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = temp
  }
  return arr
}

// 测试用例
let arr = [10, 4, 3, 2, 8, 6, 7, 1, 9, 5]

// 执行结果
console.log(insertSort(arr)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### 归并排序
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr
  }
  var middle = Math.floor(arr.length / 2)
  var left = arr.slice(0, middle)
  var right = arr.slice(middle)
  return merge(mergeSort(left), mergeSort(right))
}

function merge(left, right) {
  var result = []
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  while (left.length) {
    result.push(left.shift())
  }
  while (right.length) {
    result.push(right.shift())
  }
  return result
}

// 测试用例
let arr = [10, 4, 3, 2, 8, 6, 7, 1, 9, 5]

// 执行结果
console.log(mergeSort(arr)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### 快速排序
```javascript
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr
  }
  var pivotIndex = Math.floor(arr.length / 2)
  var pivot = arr.splice(pivotIndex, 1)[0]
  var left = []
  var right = []
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}

// 测试用例
let arr = [10, 4, 3, 2, 8, 6, 7, 1, 9, 5]

// 执行结果
console.log(quickSort(arr)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### 搜索
#### 二分搜索
```javascript
function binarySearch(arr, target) {
  let low = 0;
  let high = arr.length - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] > target) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}

// 测试用例
// 注意二分搜索数组必须是有序的
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 执行结果
console.log(binarySearch(arr, 6)) // 5
```

### 力扣 - 374. 猜数字大小
> [https://leetcode.cn/problems/guess-number-higher-or-lower/description/](https://leetcode.cn/problems/guess-number-higher-or-lower/description/)
>

猜数字游戏的规则如下：

+ 每轮游戏，我都会从 **1** 到 _**n**_ 随机选择一个数字。 请你猜选出的是哪个数字。
+ 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。

你可以通过调用一个预先定义好的接口 `**int guess(int num)**` 来获取猜测结果，返回值一共有 3 种可能的情况（`**-1**`，`**1**` 或 `**0**`）：

+ -1：我选出的数字比你猜的数字小 `**pick < num**`
+ 1：我选出的数字比你猜的数字大 `**pick > num**`
+ 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！`**pick == num**`

返回我选出的数字。

**示例 1：**

> **输入：**n = 10, pick = 6
>
> **输出：**6
>

**示例 2：**

> **输入：**n = 1, pick = 1
>
> **输出：**1
>

**示例 3：**

> **输入：**n = 2, pick = 1
>
> **输出：**1
>

**示例 4：**

> **输入：**n = 2, pick = 2
>
> **输出：**2
>

```javascript
/**
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	     -1 if num is higher than the picked number
 *			      1 if num is lower than the picked number
 *               otherwise return 0
 * var guess = function(num) {}
 */

/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function (n) {
  let low = 1
  let high = n
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    const result = guess(mid)
    if (result === 0) {
      return mid
    }
    if (result === -1) {
      high = mid - 1
    } else {
      low = mid + 1
    }
  }
  return -1
}
```

### 力扣 - 169. 多数元素
> [https://leetcode.cn/problems/majority-element/description/](https://leetcode.cn/problems/majority-element/description/)
>

给定一个大小为 `**n**` 的数组 `**nums**` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `**⌊ n/2 ⌋**` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

> **输入：**nums = [3,2,3]
>
> **输出：**3
>

**示例 2：**

> **输入：**nums = [2,2,1,1,1,2,2]
>
> **输出：**2
>

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
  let map = {}
  for (let i = 0; i < nums.length; i++) {
    if (map[nums[i]]) {
      map[nums[i]]++
    } else {
      map[nums[i]] = 1
    }
  }
  for (let key in map) {
    if (map[key] > nums.length / 2) {
      return key
    }
  }
  return -1
}

// 测试用例
console.log(majorityElement([3, 2, 3])) // 3
console.log(majorityElement([2, 2, 1, 1, 1, 2, 2])) // 2
```

### 力扣 - 70. 爬楼梯
> [https://leetcode.cn/problems/climbing-stairs/description/](https://leetcode.cn/problems/climbing-stairs/description/)
>

假设你正在爬楼梯。需要 `**n**` 阶你才能到达楼顶。

每次你可以爬 `**1**` 或 `**2**` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

> **输入：**n = 2
>
> **输出：**2
>
> **解释：**有两种方法可以爬到楼顶。
>
> 1. 1 阶 + 1 阶
>
> 2. 2 阶
>

**示例 2：**

> **输入：**n = 3
>
> **输出：**G3
>
> **解释：**有三种方法可以爬到楼顶。
>
> 1. 1 阶 + 1 阶 + 1 阶
>
> 2. 1 阶 + 2 阶
>
> 3. 2 阶 + 1 阶
>

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  if (n === 1) return 1
  if (n === 2) return 2
  let dp = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
}

// 测试用例
console.log(climbStairs(2)) // 2
console.log(climbStairs(3)) // 3
```

### 力扣 - 198. 打家劫舍
> [https://leetcode.cn/problems/house-robber/description/](https://leetcode.cn/problems/house-robber/description/)
>

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下 **，一夜之内能够偷窃到的最高金额。

**示例 1：**

> **输入：**[1,2,3,1]
>
> **输出：**4
>
> **解释：**偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>

     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**

> **输入：**[2,7,9,3,1]
>
> **输出：**12
>
> **解释：**偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>

     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  if (nums.length === 0) return 0
  if (nums.length === 1) return nums[0]
  if (nums.length === 2) return Math.max(nums[0], nums[1])
  let dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1]
}

// 测试用例
console.log(rob([1, 2, 3, 1])) // 4
console.log(rob([2, 7, 9, 3, 1])) // 12
```

### 力扣 - 55. 跳跃游戏
> [https://leetcode.cn/problems/jump-game/description/](https://leetcode.cn/problems/jump-game/description/)
>

给你一个非负整数数组 `**nums**` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `**true**` ；否则，返回 `**false**` 。

**示例 1：**

> **输入：**nums = [2,3,1,1,4]
>
> **输出：**true
>
> **解释：**可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
>

**示例 2：**

> **输入：**nums = [3,2,1,0,4]
>
> **输出：**false
>
> **解释：**无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
>

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function (nums) {
  let max = 0
  for (let i = 0; i < nums.length; i++) {
    if (i > max) return false
    max = Math.max(max, i + nums[i])
    if (max >= nums.length - 1) return true
  }
  return false
}

// 测试用例
console.log(canJump([2, 3, 1, 1, 4])) // true
console.log(canJump([3, 2, 1, 0, 4])) // false
```

### 力扣 - 455. 分发饼干
> [https://leetcode.cn/problems/assign-cookies/description/](https://leetcode.cn/problems/assign-cookies/description/)
>

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `**i**`，都有一个胃口值 `**g[i]**`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `**j**`，都有一个尺寸 `**s[j]**` 。如果 `**s[j] >= g[i]**`，我们可以将这个饼干 `**j**` 分配给孩子 `**i**` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

> **输入:** g = [1,2,3], s = [1,1]
>
> **输出:** 1
>
> **解释:** 
>
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
>
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
>
> 所以你应该输出1。
>

**示例 2:**

> **输入:** g = [1,2], s = [1,2,3]
>
> **输出:** 2
>
> **解释:** 
>
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
>
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
>
> 所以你应该输出2.
>

```javascript
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function (g, s) {
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)
  let res = 0
  let i = 0
  let j = 0
  while (i < g.length && j < s.length) {
    if (g[i] <= s[j]) {
      res++
      i++
      j++
    } else {
      j++
    }
  }
  return res
}

// 测试用例
var g1 = [1, 2, 3]
var s1 = [1, 1]

var g2 = [1, 2]
var s2 = [1, 2, 3]
console.log(findContentChildren(g1, s1)) // 1
console.log(findContentChildren(g2, s2)) // 2
```

### 力扣 - 122. 买卖股票的最佳时机 II
> [https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
>

给你一个整数数组 `**prices**` ，其中 `**prices[i]**` 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 你能获得的 _**最大**_ 利润 。

**示例 1：**

> **输入：**prices = [7,1,5,3,6,4]
>
> **输出：**7
>
> **解释：**在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>
>      总利润为 4 + 3 = 7 。
>

**示例 2：**

> **输入：**prices = [1,2,3,4,5]
>
> **输出：**4
>
> **解释：**在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>
>      总利润为 4 。
>

**示例 3：**

> **输入：**prices = [7,6,4,3,1]
>
> **输出：**0
>
> **解释：**在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
>

```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  let num = 0
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      num += prices[i] - prices[i - 1]
    }
  }
  return num
}

// 测试用例
console.log(maxProfit([7, 1, 5, 3, 6, 4])) // 7
console.log(maxProfit([1, 2, 3, 4, 5])) // 4
console.log(maxProfit([7, 6, 4, 3, 1])) // 0
```

